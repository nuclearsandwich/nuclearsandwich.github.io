<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Mad Ramblings of a Lunatic Hacker]]></title>
  <link href="http://blog.nuclearsandwich.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://blog.nuclearsandwich.com/"/>
  <updated>2012-06-17T14:08:25-07:00</updated>
  <id>http://blog.nuclearsandwich.com/</id>
  <author>
    <name><![CDATA[Steven! RagnarÃ¶k]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[There Are 10 Types of Tests. You Need Both of Them]]></title>
    <link href="http://blog.nuclearsandwich.com/blog/2011/10/28/there-are-10-types-of-tests-you-need-both-of-them/"/>
    <updated>2011-10-28T02:22:00-07:00</updated>
    <id>http://blog.nuclearsandwich.com/blog/2011/10/28/there-are-10-types-of-tests-you-need-both-of-them</id>
    <content type="html"><![CDATA[<p>Over the course of the last year, and especially in the last two to three months
I have been internalizing and witnessing for myself the extreme benefits of
accompanying your code with a test suite which matches your code in quality.
By this I mean that it is difficult (and damn frustrating) to write good tests
for poor code. At my current skill level as a programmer there's code in my
primary code base that is so bad (yep, I wrote that code too) that I am unable
to write good tests for it. Up until four or five weeks ago, coinciding with my
second readings of <a href="http://pragprog.com/book/achbd/the-rspec-book">The RSpec Book</a>, and <a href="http://pragprog.com/book/hwcuc/the-cucumber-book">The Cucumber Book</a>, sitting in
as a guest panelist on <a href="http://rubyrogues.com/book-club-exceptional-ruby/">Ruby Rogues</a>, and watching a bunch of
<a href="https://www.destroyallsoftware.com/screencasts">Destroy All Software</a>, I realized that in order to gain the benefits of TDD
being touted by some of the most respected members of the Ruby community, I
needed better tests. Specifically better isolated tests.</p>

<h2>Isolated Tests</h2>

<p>I recently had to completely justify my desire to add and grow isolated tests
for production code. The argument against doing so was simply that if the <em>whole
point</em> of isolated tests is to know when something breaks in the future, an
integrated test suite will pick up those failures just as well. Therefore
isolated tests are a waste of time and engineering effort.</p>

<p>This argument <em>is</em> correct, provided the only thing you use your isolated tests
for is protection from regressions. However, doing so leaves out what is to my
mind the <strong>greatest</strong> and most profound advantage of isolated testing, which is
immediate, focused feedback. I definitely think I'm inventing terms here so
please indulge me while I clarify them.</p>

<ul>
<li>Immediate: <em>The result (success or failure) can be observed right away.</em></li>
<li>Focused: <em>The cause of any failure is known to be within the system under
test.</em></li>
</ul>


<p>Anyone who has worked in software for a substantial amount of time knows that
we are each our own worst enemy and the temptation to add unnecessary complexity
is a constant bother. How many of us have added arguments to methods only to
use the default value every time. I call these bullshit arguments, because they
piss me off when I have to put up with them. The joy in a test with truly
immediate feedback is the laser focus that they give you when working on a
system. You're literally doing one thing at a time and checking that you get the
expected result even when it isn't success. When you get the failure you expect,
you simply move on, and when you get an unexpected failure it causes you to
identify the disparity between your mental model of the system and the computer
model and correct it. Since these tests are isolated and generally run in less
than a second, there is essentially no penalty for running the tests with
monstrous frequency. When you do have to stop, it is to make a correction,
even if it is just a mental correction. The time you save fixing it early is
more than enough to justify the low cost of running the test.</p>

<p>One of the downsides of this type of testing is that you are treating anything
which isn't the system under test as an external service and therefore
stubbing the interactions with it. This works great for fast, clean-room tests
but it means that the burden of ensuring that the assumptions you make in one
test are validated in the respective tests for your other systems is entirely on
the programmer and since programmers are human, this will eventually lead to
mistakes.</p>

<p>My personal favorite aspect of isolated tests is how informative they can be
about your system. It's pretty common knowledge that if your tests are a pain in
the ass to write, it's a good indication that your code is too-tightly coupled
and refactoring to follow the <a href="http://avdi.org/devblog/2011/07/05/demeter-its-not-just-a-good-idea-its-the-law/">Law of Demeter</a> and <a href="http://blog.rubybestpractices.com/posts/gregory/055-issue-23-solid-design.html">SOLID</a> design
principles is a good idea.</p>

<h2>Integrated Tests</h2>

<p>One of the scariest things that happened to me in recent memory was discovering
that people were surprised when after arguing in favor of getting higher quality
unit tests I was still unsatisfied because our integrated tests also needed
attention and improvement. I found this a little disturbing (okay, I found this
really disturbing) because I can't imagine how long it would take to manually
verify that I didn't overlook anything in the major refactoring or feature
addition I just performed. I certainly don't budget the time to manually test
every resource and parameter combination by hand. I might do so initially
because a major disadvantage to integrated tests is in the difficulty of doing
exploratory testing at this level. As a result, when writing integrated tests, I
tend to rely on manual experimentation to determine how my system behaves in
undefined situations, make a decision on the appropriateness of that behavior
and then solidify that set of interactions into a group of tests. One of the
nice things about integrated tests is that once written, they tend not to change
unless your expected end-user behavior changes. This is afforded by the
"bigger picture" nature of integrated tests where you are less concerned with
the exact behavior of any one unit and instead are validating the result of
system-wide operation and interaction. Thus, integrated tests are largely immune
to internal refactoring.</p>

<p>As one can imagine, the strengths of isolated tests are the weaknesses of
integrated tests. When something is wrong, particularly in a complex interaction
that touches many parts of the system, it can be unclear exactly where the
problem in the codebase is when an integrated test fails. If you get an actual
exception, you'll have a stacktrace to guide you, but those tend to be unhelpful
errors like an unexpected nil and rarely is it obvious at what level the nil was
assigned and how long it had been propagated upward until the failure. So it
can be said that integrated tests are not focused since there is no indication
of precisely where in the system the failure has occurred. Additionally,
integrated tests mandate that you test your full software stack. Any persistence
layers, external services, background tasks, and other specific tools you're
using should be tested during this phase. As you can imagine testing all of
these things takes time and computing power. It is not feasible to expect even
a subset of an integrated test suite to run in the same magnitude of time as
isolated tests, what this means is the tests are no longer immediate. Thus,
they are not suitable for running at every pass of your TDD cycle. Only when you
believe the feature to be complete.</p>

<h2>Conclusions</h2>

<p>So if isolated tests don't identify incongruities between subsystems and
integrated tests are too slow to run during an immediate feedback TDD cycle,
which do you use? As you may have surmised from the title, the answer is...
both.</p>

<p><a href="http://pragprog.com/book/hwcuc/the-cucumber-book">The Cucumber Book</a> suggests that "It's sometimes said that unit tests ensure
you 'build the thing right', while acceptance tests ensure you 'build the
right thing'." I also like Avdi Grim's simile of mocks being like hydrogen
peroxide in that they both fizz up around problems.</p>

<p>With our twin goals of systematic coverage and focus during development in mind,
let's recap how each set of tests is used.</p>

<p>When you know what you you're building but not how, reach for the integrated
tests. Define the desired outcome at the high level and then run that test again
when you think you've got it down. Start thinking about the different aspects of
that problem and decomposing them. Then devise a system of smaller tests
mirroring the smaller objects and functions you'll use to accomplish that goal.
Isolated tests are there once you're ready to do exactly that. There to aid
you in that mission and guide you toward good design decisions. "I'll do what
the tests tell me" is not an uncommon phrase from me.</p>

<p><em>Isolated regression tests are a side effect of good TDD, they're more important
during the process than after.</em></p>

<p><em>Integrated tests are the ones you bring home and show your mother. The ones you
can be proud of at the end of the day.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Look at Ruby Case Expressions]]></title>
    <link href="http://blog.nuclearsandwich.com/blog/2011/09/08/a-look-at-ruby-case-expressions/"/>
    <updated>2011-09-08T08:33:00-07:00</updated>
    <id>http://blog.nuclearsandwich.com/blog/2011/09/08/a-look-at-ruby-case-expressions</id>
    <content type="html"><![CDATA[<p>Ruby, like many languages has a case-when construct for more refined conditional
execution than if-then-else can provide. Technically all case constructs could
be written as if-then-else-if-then...else but you wouldn't enjoy it.</p>

<h2>Ruby's case-when is an expression</h2>

<p>However, there are a number of things that make Ruby's case-when special. The
first comes from Ruby's functional roots. It's powerful but deceptively simple.
Ruby's case-when construct is an <em>expression</em>. Which means, among other things,
it returns a value.</p>

<p>In a traditional imperative style a case statement might look like:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">conditional_variable</span> <span class="o">=</span> <span class="ss">:some_default_value</span>
</span><span class='line'><span class="k">case</span> <span class="n">our_condition</span>
</span><span class='line'><span class="k">when</span> <span class="ss">:first</span>
</span><span class='line'>  <span class="n">conditional_variable</span> <span class="o">=</span> <span class="ss">:one_thing</span>
</span><span class='line'><span class="k">when</span> <span class="ss">:then</span>
</span><span class='line'>  <span class="n">conditional_variable</span> <span class="o">=</span> <span class="ss">:another</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The that isn't ideal for a number of reasons. <code>conditional_variable</code> is set
visibly three times which as any freshman can tell you is frowned upon.
Academics have stuffier reasons for it but the most important is that it
decreases readability because we aren't sure what the value will be after
execution. Setting it so many times is also a code duplication, albeit a small
one. We can take advantage of Ruby's case-when <em>expression</em> with this code:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">conditional_variable</span> <span class="o">=</span> <span class="k">case</span> <span class="n">our_condition</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;                   when :first</span>
</span><span class='line'><span class="sr">                     :one_thing</span>
</span><span class='line'><span class="sr">                   when :then</span>
</span><span class='line'><span class="sr">                     :another</span>
</span><span class='line'><span class="sr">                   else</span>
</span><span class='line'><span class="sr">                     :some_default_value</span>
</span><span class='line'><span class="sr">                   end</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Doesn't that look nicer? <code>conditional_variable</code> is only set once and the
intent is clear, we want the value to depend on <code>our_condition</code>.</p>

<h2>case-when uses triple equals for comparison</h2>

<p>This got me good this morning and spawned this article. If you're not familiar
with <code>===</code> in Ruby then the best explanation comes from <em>_why's Poignant Guide
to Ruby</em> which really is worth reading. I've referred back to it multiple times
to help myself and those around me fully understand basic Ruby concepts like
<code>nil</code>, truthiness and falsiness, and, <strong>fanfare please</strong>, double equals versus
triple equals.</p>

<blockquote><p>The double equals gives the appearance of a short link of ropes, right
along the sides of a red carpet where only <code>true</code> can be admitted.
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">approaching_guy</span> <span class="o">==</span> <span class="kp">true</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;That necklace is classic&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
...
[This case-when statement]</p></blockquote>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">case</span> <span class="n">year</span>
</span><span class='line'><span class="k">when</span> <span class="mi">1894</span>
</span><span class='line'>  <span class="s2">&quot;Born.&quot;</span>
</span><span class='line'><span class="k">when</span> <span class="p">(</span><span class="mi">1895</span><span class="o">.</span><span class="n">.</span><span class="mi">1913</span><span class="p">)</span>
</span><span class='line'>  <span class="s2">&quot;Childhood in Lousville, Winston Co., Mississippi.&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="s2">&quot;No information about this year.&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<blockquote><p>is identical to
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="mi">1894</span> <span class="o">===</span> <span class="n">year</span>
</span><span class='line'>  <span class="s2">&quot;Born.&quot;</span>
</span><span class='line'><span class="k">elsif</span> <span class="p">(</span><span class="mi">1895</span><span class="o">.</span><span class="n">.</span><span class="mi">1913</span><span class="p">)</span> <span class="o">===</span> <span class="n">year</span>
</span><span class='line'>  <span class="s2">&quot;Childhood in Lousville, Winston Co., Mississippi.&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="s2">&quot;No information about this year.&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
The <strong>triple equals</strong> is a length of velvet rope, checking values much like
the <strong>double equals</strong>. It's just: the triple equals is a longer rope and it
sags a bit in the middle. It's not as strict, it's a bit more flexible.
Take the Ranges above. <code>(1895..1913)</code> isn't at all equal to <code>1905</code>.</p>

<p>No, the Range <code>(1895..1913)</code> is only truly equal to any other Range
<code>(1895..1913)</code>. In the case of a Range, the triple equals cuts you a break
and lets the Integer <code>1905</code> in, because even though it's not equal to the
Range, it's included in the set of Integers represented by the Range. Which
is good enough in some cases, such as the timeline I put together earlier.</p></blockquote>

<h2>My Mistake</h2>

<p>This is what I did which caused me to write this as penance.
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">local_tweet_object</span> <span class="n">input</span>
</span><span class='line'>  <span class="n">tweet_hash</span> <span class="o">=</span> <span class="k">case</span> <span class="n">input</span><span class="o">.</span><span class="n">class</span> <span class="c1"># the screw-up</span>
</span><span class='line'>  <span class="k">when</span> <span class="nb">String</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;MultiJson.decode input</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;  when Hash&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">input</span>
</span><span class='line'><span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>  <span class="k">else</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;fail ArgumentError.new(</span>
</span><span class='line'><span class="sr">  &quot;Cannot process </span><span class="si">#{</span><span class="n">input</span><span class="o">.</span><span class="n">class</span><span class="si">}</span><span class="sr"> only String or Hash&quot;)</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;  end</span>
</span><span class='line'><span class="sr">  LocalTweet.new tweet_hash</span>
</span><span class='line'><span class="sr">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This code was raising the following error.</p>

<p><code>ArgumentError: I don't want Hash give me only String or Hash</code>
... <em>huh?</em></p>

<p>At first glance it looked fine, but then we remember that case-when uses <code>===</code>.
Again, we think "this shouldn't be an issue, if it's good enough for <code>==</code> it
should be fine for <code>===</code>." But <code>===</code> behaves specially for certain types in Ruby
such as Classes, Arrays, and as we saw before, Ranges.</p>

<p>For simple scalar values <code>===</code> acts like you expect.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>12 === 12 #=> true
</span><span class='line'>12 === 13 #=> false
</span><span class='line'>:rats === :rats #=> true
</span><span class='line'>"pens" === "pens" #=> true
</span><span class='line'>"space" === "fact" #=> false</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>And we know how <code>===</code> treats ranges
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(8..64) === 32 #=> true</span></code></pre></td></tr></table></div></figure></notextile></div>
But note that
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(8..64) === (8..64) #=> false</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Suddenly!
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Integer === 12 #=> true!</span></code></pre></td></tr></table></div></figure></notextile></div>
waitaminute.. what?</p>

<p>So Ruby can tell that <code>12</code> is a type of Integer and thus <code>===</code> can be described
partially as an includes and typeof operator. But there are some further
gotchas.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[ 1, 2, 3 ] === 1#=> true
</span><span class='line'>[ 1, 2, 3 ] === [ 1, 2, 3 ]                         #=> true
</span><span class='line'>[ 1, 2, 3 ] === [ 1, 2 ]                            #=> false
</span><span class='line'>{ :foo => :bar } === { :foo => :bar }               #=> true
</span><span class='line'>{ :foo => :bar } === :foo                           #=> false
</span><span class='line'>{ :foo => :bar, :baz => :qux } === { :foo => :bar } #=> false</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>===</code>'s behavior isn't completely intuitive even within Ruby's standard Classes.
Which brings us (finally) back around to my original error.
<code>Hash === Hash #=&gt; false</code></p>

<p>The fix is simple, just change
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>case input.class</span></code></pre></td></tr></table></div></figure></notextile></div>
to
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>case input</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>I posted on identi.ca a friendly notice about this easy mistake and was asked to
provide clarification. So here, just over 24 hours late, it is. The full source
code is provided <a href="https://gist.github.com/1112335">here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why You Shouldn't Use Factories in Unit-level Tests or Specs]]></title>
    <link href="http://blog.nuclearsandwich.com/blog/2011/08/31/why-you-shouldnt-use-factories-in-unit-level-tests-or-specs/"/>
    <updated>2011-08-31T05:11:00-07:00</updated>
    <id>http://blog.nuclearsandwich.com/blog/2011/08/31/why-you-shouldnt-use-factories-in-unit-level-tests-or-specs</id>
    <content type="html"><![CDATA[<p>They're tightly fucking coupled! That's Why</p>

<p><strong>UPDATE:</strong> Or as Steve Klabnik puts it more precisely and politely:</p>

<blockquote><p>factories are integration tests by definition, because they do not exercise a
single unit.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why Ruby Needs Heroes]]></title>
    <link href="http://blog.nuclearsandwich.com/blog/2011/08/19/why-ruby-needs-heroes/"/>
    <updated>2011-08-19T12:12:00-07:00</updated>
    <id>http://blog.nuclearsandwich.com/blog/2011/08/19/why-ruby-needs-heroes</id>
    <content type="html"><![CDATA[<p><em>A reflection on the Ruby community's tendency to celebrate individual
developers and what good comes of it.</em></p>

<p>The Ruby community isn't unique in its tendency for celebrating rockstar
developers but after examining the communities history it would seem that we
burn them out bright and fast.</p>

<p>When I first became involved in the community I had heard of almost no one. My
first hero is my friend Erik Ostrom to whom I owe a great deal for my first and
second introductions to Ruby. Without you Erik I would be missing out on the
most fun, passionate, and rewarding hacking I have ever done. I have you to
thank for my introductions to rhe MVC pattern, idiomatic programming, and the
process of developing software. I also owe you a big thanks for pointing me to
_why's (Poignant) Guide to Ruby.</p>

<p>Which leads nicely into my second hero <em>why the lucky stiff. The Guide when I
first read it was the most refreshing and maddeningly beautiful piece of
technical literature I had ever encountered and remains so to this day. Never
before had I seen a language presented side by side with English hold its
expressiveness the way Ruby did. It took me three tries to finish the Guide but
I have read over its pages many times reminding myself to "use what Ruby gives
[me]" and it is still my goto for explaining nil, truthiness, and falsiness in
Ruby. If I were to teach programming in an art department, The Guide would be my
textbook. But </em>why gave me more than the guide. Through Camping I was able to
study "magic" and be exposed to the raw untamed power of metaprogramming in
Ruby. Even though I had missed the whole hullabaloo surrounding _why's exit
from the community by a matter of weeks his work has had a lasting and profound
effect on me and I thank him.</p>

<p>Like many developers my first full application in Ruby and real test of what I
learned was using Ruby on Rails. Rails 2.3.5 to be precise. This marks me as a
new kid on the block I know, but let's face it, I am. I have been living with
Ruby for little more than two years. But that's the evolution of community
without new blood it dries out. Anyway through this early stage I had a
collection of mentors. The most prolific of which wasn't even aware of it at the
time.</p>

<p>Ryan Bates, your Railscasts helped guide me not only on specific challenges I
was facing building my first production app but also provided my first exposure
to lots of quality Ruby code and process. One thing the Ruby community gets on a
fundamental level is that process matters and you were my first big introduction
to that. You also introduced me to rvm and by extension my next hero.</p>

<p>Wayne Seguin, rvm is a colossal undertaking. Managing development environments
has always been a pain and you shaved one of the biggest, hairiest yaks ever to
stand in the middle of the room.
MixedMetaphorException: "Yaks aren't elephants."</p>

<p>You are also a fabulous example of a project maintainer I don't have a specific
IRC story of my own but that only speaks to the quality of your work. You're
also a wonderful example of a polyglot Rubyist and really show what can happen
when Rubyists take their knowledge and experience and apply it to funny little
languages like bash.</p>

<p>Last April I had the pleasure of meeting Steve Klabnik at the very first
CodeConf. One of the coolest things about you Steve is that you're pretty much
my age. It was so inspiring to see you, such an obviously accepted member of the
Ruby community, so close to my own age. You indirectly informed me that the amount
of effort required to really get involved and make a difference wasn't in the
depressingly distant future and this has motivated me substantially in my
efforts to give back even as I receive.</p>

<p>Thanks man, you rock</p>

<p>Lately I have been reading a lot of stuff from Avdi Grimm. You're style is so
refined and decisive. Few people think about the meaning and reason behind their
code and design decisions as you clearly do. Lately I have been turning to your
writings when I find myself wondering about the best way to do something.</p>

<p>So my journey through Ruby has brought me across the paths of these heroes and
so many more. But what motivates me to think of these fine folks this way even
when they may not want the attention. How many feel overly pressured by or
undeserving of their status. When thinking on this, I am reminded of Firefly.
(If you haven't seen it, seriously do yourself a favor and watch it.)</p>

<!--![Jaynestown](/images/blog/jaynestown.jpg) -->


<p>Specifically the Hero of Canton episode in which Jayne, the least noble of the
protagonists, is remembered as a folk hero on a backwater mining colony for
accidentally dropping crates of money over the mining camps. At the end Jayne
can't understand what they see in him when dropping the money at all was simply
a dishonest mistake as the episode wraps up he's told that the statue in his
honor isn't for him, it is for the miners. We build heroes out of you because we
see qualities in you we hope to someday find in ourselves. So please, whether
you're a Jayne Cobb or Malcom Reynolds, if someone thinks of you as their hero,
just be proud that you've done something extraordinary and they hope to follow
suit.</p>

<p>Happy _whyday,
Steven!</p>
]]></content>
  </entry>
  
</feed>
