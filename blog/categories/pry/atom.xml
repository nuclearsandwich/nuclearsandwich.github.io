<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: pry | Mad Ramblings of a Lunatic Hacker]]></title>
  <link href="http://blog.nuclearsandwich.com/blog/categories/pry/atom.xml" rel="self"/>
  <link href="http://blog.nuclearsandwich.com/"/>
  <updated>2012-05-16T22:00:32-07:00</updated>
  <id>http://blog.nuclearsandwich.com/</id>
  <author>
    <name><![CDATA[Steven! RagnarÃ¶k]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How I Used a "Debugging Feature" of Pry to Build Cage]]></title>
    <link href="http://blog.nuclearsandwich.com/blog/2012/05/16/how-i-used-a-debugging-feature-of-pry-to-build-cage/"/>
    <updated>2012-05-16T21:57:00-07:00</updated>
    <id>http://blog.nuclearsandwich.com/blog/2012/05/16/how-i-used-a-debugging-feature-of-pry-to-build-cage</id>
    <content type="html"><![CDATA[<p><a href="http://pry.github.com">Pry</a> is an alternative interactive Ruby environment
similar to IRB. In addition to looking a little nicer through nearly live
colorization, Pry offers some pretty powerful features for exploring, modifying,
and debugging Ruby applications in a live system.</p>

<p>Pry's namesake ability to "pry" open an object is not limited to debugging use.
It's actually a really straightforward way to build any kind of domain specific
REPL. I think I just coined that term but it fits well and you'll soon see why.</p>

<h2>The Backstory</h2>

<p>When I working at <a href="http://nowbox.com">NOWBOX</a> I spent a lot of time hitting our
API during ad-hoc testing. I was doing enough of this that just using curl
wasn't cutting it.</p>

<p>Don't get me wrong, curl is awesome and super useful. But it lacks a few
niceties. Chief among them curl, like HTTP, is stateless without the use of
cookie files and given that we were using a token-based authentication system,
simulating device-API interaction using exclusively curl was neither fun nor
easy.</p>

<p>During this time, we were also using
<a href="https://github.com/brynary/rack-test">Rack::Test</a>, which I really like. It's a
solid and purposeful DSL and great at what it does. What it isn't good at is
being interactive. I'd get colourful explosions(stacktraces) whenever I tried to
pry into and look at a test using <code>Rack::Test</code>.</p>

<p>We already had the awesome <a href="https://github.com/technoweenie/faraday">Faraday</a>
included in our project, so I hacked together a quick rake task that would set
up a <code>Faraday::Connection</code> and pry into it. What did this get me? I now had my
interactive <code>Rack::Test</code>.</p>

<h3>Cage Version -1</h3>

<p>``` ruby Rakefile
task :client_console do
  require "faraday"
  require "pry"
  uri = case ENV["target"]</p>

<pre><code>    when "production"
      "http://api.superawesomepage.com/1/"
    when "staging"
      "http://api.staging.superawesomepage.com/1/"
    else
      "http://localhost:3000/1/"
    end
</code></pre>

<p>  Faraday::Connection.new(uri).pry
end
```</p>

<h2>Building the Gem</h2>

<p>Pry made this really easy. So easy that later on, when I wanted to rewrite the
above code and turn it into a reusable gem I kept the same strategy.</p>

<p>I build my DSL class, <code>Cage::Console</code>, which also handles all the initialization
such as config file loading and default values for variables. It also overloads
some of Pry's settings to get a more interesting prompt string and suppressing
they default <code>~/.pryrc</code> config file loading.</p>

<p>``` ruby lib/cage/console.rb
class Cage::Console
  def initialize config_file = nil</p>

<pre><code>configure_pry
read_config_file File.expand_path config_file if config_file
default_to_rubygems
reinitialize_connection
</code></pre>

<p>  end</p>

<p>  ## The rest of the show
  ## ...
  ## The party starter
  def self.start! *args</p>

<pre><code>new(*args).pry
</code></pre>

<p>  end
end
```</p>

<p>The rest of the class is the domain specific stuff that deals with delegating to
the Faraday connection object and building the response object. I built my own
wrapper around Faraday's response so I could improve how they are displayed as
return values.</p>

<p>``` ruby lib/cage/response.rb
class Cage::Response
  ## Delegating code
  ## ...
  ## Prettification code
  def inspect</p>

<pre><code>&lt;&lt;-PRETTY
</code></pre>

<p>Status: #{status}</p>

<p>Headers:</p>

<h1>{headers.map { |k, v| "  #{k}: #{v}" }.join "\n"}</h1>

<p>Body:
  #{body}</p>

<h1>&lt;Cage::Response:(#{url})></h1>

<pre><code>  PRETTY
end
</code></pre>

<p>  end
end
```</p>

<p>It's certainly verbose but the primary function is to show you the complete
result of an HTTP request, which it does.</p>

<h2>Concluding</h2>

<p>That's  basically all there is to it. This feature of Pry that's mainly
advertised as a way to get hands-on with your objects for debugging is also a
great way to build a domain specific or domain focused interactive environment.
Depending on how much you want to customize Pry's interface you don't even need
a thorough understanding of Pry's internals. If you're more interested in the
features <em>of</em> Cage than the mechanics of its construction you can install it
from RubyGems using <code>gem install cage</code> or check out its <a href="/cage">project page</a>.
The complete source for Cage is on
<a href="https://github.com/nuclearsandwich/cage">GitHub</a>. I hope you use Pry and Cage
to build awesome stuff!</p>
]]></content>
  </entry>
  
</feed>
